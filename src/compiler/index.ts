import { format } from "prettier";
import { Node, parse, ParseError, isParseError } from "../parser/index.js";

const RESULT = "__sb";

const PREFIX = String.raw`
class __EtsStringBuilder {
  string: string = "";
  isGlue: boolean = false;
  glue() { this.isGlue = true; }
  append(string: string, preserveIndent: boolean = false) {
    if (this.isGlue && string.startsWith("\n")) {
      string = string.slice(1);
    }
    if (preserveIndent) {
      const indent = this.indent;
      const parts = string.split("\n");
      this.string += parts[0];
      for (const part of parts.slice(1)) {
        this.string += "\n" + " ".repeat(indent) + part;
      }
    } else {
      this.string += string;
    }
    this.isGlue = false;
  }
  get indent() {
    const parts = this.string.split("\n");
    return parts[parts.length - 1].length;
  }
}`.trimStart();

function compile(nodes: Node[], { isAsync }: { isAsync: boolean }): string {
  let compiled = "";
  let indent = "";

  function write(text: string): void {
    compiled += indent + text;
  }

  for (const node of nodes) {
    switch (node.type) {
      case "header": {
        const props = /(interface|type) Props/.test(node.content)
          ? "Props"
          : "unknown";
        write(`${node.content}\n\n${PREFIX}\n\n`);
        write(
          `export default ${
            isAsync ? "async" : ""
          } function (props: ${props}): ${
            isAsync ? "Promise<string>" : "string"
          } {\n`
        );
        indent += "  ";
        write(`const ${RESULT} = new __EtsStringBuilder();\n`);
        break;
      }
      case "text": {
        const content = node.content;
        if (content) write(`${RESULT}.append(${JSON.stringify(content)});\n`);
        break;
      }
      case "glue": {
        write(`${RESULT}.glue();\n`);
        break;
      }
      case "expression": {
        write(
          `${RESULT}.append((${
            node.content
          }).toString(), ${node.preserveIndent.toString()});\n`
        );
        break;
      }
      case "statement": {
        write(`${node.content}\n`);
        break;
      }
      default: {
        const exhaust: never = node;
        return exhaust;
      }
    }
  }

  write(`return ${RESULT}.string;\n`);
  indent = "";
  write(`}\n`);

  return compiled;
}

export function compiler(
  template: string,
  templatePath: string
): string | ParseError {
  const parsed = parse(template);
  if (isParseError(parsed)) {
    return parsed;
  }

  const heading = `/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 *
 * Run \`npx ets\` or \`yarn ets\` to regenerate this file.
 * Source: ${templatePath}
 */
/* eslint-disable */

`;
  const isAsync = templatePath.endsWith(".async.ets");
  const file = heading + compile(parsed, { isAsync });
  return format(file, { parser: "typescript" });
}
