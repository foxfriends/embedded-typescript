import { format } from "prettier";
import { Node, parse, ParseError, isParseError } from "../parser/index.js";

const RESULT = "__sb";

const PREFIX = String.raw`
class __EtsStringBuilder {
  string: string = "";
  isGlue: boolean = false;
  glue() { this.isGlue = true; }
  append(string: string, preserveIndent: boolean = false) {
    if (this.isGlue && string.startsWith("\n")) {
      string = string.slice(1);
    }
    if (preserveIndent) {
      const indent = this.indent;
      const parts = string.split("\n");
      this.string += parts[0];
      for (const part of parts.slice(1)) {
        this.string += "\n" + " ".repeat(indent) + part;
      }
    } else {
      this.string += string;
    }
    this.isGlue = false;
  }
  get indent() {
    const parts = this.string.split("\n");
    return parts[parts.length - 1].length;
  }
}`.trimStart();

// NOTE: I copied this out of another package and adjusted slightly to make it typescript and also
// not look like 2012.
const HTML_ESCAPER = String.raw`
const HTML_NEED_ESCAPE = /["'&<>]/
function __escape(string: string): string {
  const match = HTML_NEED_ESCAPE.exec(string)
  if (!match) return string;
  let html = '';
  let index = 0;
  let lastIndex = 0;
  for (index = match.index; index < string.length; ++index) {
    let escape;
    switch (string.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;'
        break
      case 38: // &
        escape = '&amp;'
        break
      case 39: // '
        escape = '&#39;'
        break
      case 60: // <
        escape = '&lt;'
        break
      case 62: // >
        escape = '&gt;'
        break
      default:
        continue
    }
    if (lastIndex !== index) html += string.substring(lastIndex, index);
    lastIndex = index + 1;
    html += escape;
  }
  return lastIndex !== index
    ? html + string.substring(lastIndex, index)
    : html;
}
`;

function compile(
  nodes: Node[],
  { isAsync, isHtml }: { isAsync: boolean; isHtml: boolean }
): string {
  let compiled = "";
  let indent = "";

  function write(text: string): void {
    compiled += indent + text;
  }

  for (const node of nodes) {
    switch (node.type) {
      case "header": {
        const props = /(interface|type) Props/.test(node.content)
          ? "Props"
          : "unknown";
        write(`${node.content}\n\n${PREFIX}\n\n`);
        if (isHtml) {
          write(`${HTML_ESCAPER}\n\n`);
        }
        write(
          `${isAsync ? "async " : ""}function render(props: ${props}): ${
            isAsync ? "Promise<string>" : "string"
          } {\n`
        );
        indent += "  ";
        write(`const ${RESULT} = new __EtsStringBuilder();\n`);
        break;
      }
      case "text": {
        const content = node.content;
        if (content) write(`${RESULT}.append(${JSON.stringify(content)});\n`);
        break;
      }
      case "glue": {
        write(`${RESULT}.glue();\n`);
        break;
      }
      case "expression": {
        let string = `(${node.content}).toString()`;
        if (isHtml && !node.raw) {
          string = `__escape(${string})`;
        }
        write(
          `${RESULT}.append(${string}, ${node.preserveIndent.toString()});\n`
        );
        break;
      }
      case "statement": {
        write(`${node.content}\n`);
        break;
      }
      default: {
        const exhaust: never = node;
        return exhaust;
      }
    }
  }

  write(`return ${RESULT}.string;\n`);
  indent = "";
  write("}\nexport default render;\n");

  return compiled;
}

export function compiler(
  template: string,
  templatePath: string
): string | ParseError {
  const parsed = parse(template);
  if (isParseError(parsed)) {
    return parsed;
  }

  const heading = `/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 *
 * Run \`npx ets\` or \`yarn ets\` to regenerate this file.
 * Source: ${templatePath}
 */
/* eslint-disable */

`;
  const isAsync = templatePath.includes(".async.");
  const isHtml = templatePath.includes(".html.");
  const file = heading + compile(parsed, { isAsync, isHtml });
  return format(file, { parser: "typescript" });
}
